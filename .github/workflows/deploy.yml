name: Deploy - Production Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging

  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.github/**'

env:
  PHP_VERSION: '8.3'
  NODE_VERSION: '20'

jobs:
  # Build and Test
  build-test:
    name: Build and Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run CI tests
        uses: ./.github/workflows/ci.yml

  # Deploy to Staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-test
    if: |
      github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging' ||
      github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment:
      name: staging
      url: https://staging.salon.app

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.STAGING_SSH_KEY }}
          SSH_HOST: ${{ secrets.STAGING_HOST }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H $SSH_HOST >> ~/.ssh/known_hosts

      - name: Deploy to staging server
        env:
          SSH_HOST: ${{ secrets.STAGING_HOST }}
          SSH_USER: ${{ secrets.STAGING_USER }}
          DEPLOY_PATH: ${{ secrets.STAGING_DEPLOY_PATH }}
        run: |
          ssh -i ~/.ssh/deploy_key $SSH_USER@$SSH_HOST << 'ENDSSH'
            set -e

            echo "ðŸš€ Deploying to staging..."

            # Navigate to deployment directory
            cd ${{ secrets.STAGING_DEPLOY_PATH }}

            # Pull latest changes
            git fetch origin
            git reset --hard origin/main

            # Build and deploy with Docker
            docker-compose -f docker-compose.yml -f docker-compose.staging.yml down
            docker-compose -f docker-compose.yml -f docker-compose.staging.yml build --no-cache
            docker-compose -f docker-compose.yml -f docker-compose.staging.yml up -d

            # Wait for services to be ready
            echo "â³ Waiting for services to start..."
            sleep 10

            # Run migrations
            echo "ðŸ“Š Running database migrations..."
            docker-compose exec -T app php artisan migrate --force

            # Clear and cache config
            echo "ðŸ”§ Optimizing application..."
            docker-compose exec -T app php artisan config:cache
            docker-compose exec -T app php artisan route:cache
            docker-compose exec -T app php artisan view:cache

            # Clear application cache
            docker-compose exec -T app php artisan cache:clear

            # Restart queue workers
            docker-compose restart queue

            echo "âœ… Staging deployment complete!"
          ENDSSH

      - name: Health check
        run: |
          sleep 10
          curl --fail https://staging.salon.app/api/health || exit 1
          echo "âœ… Health check passed"

      - name: Notify deployment
        uses: 8398a7/action-slack@v3
        if: always()
        with:
          status: ${{ job.status }}
          text: 'Staging deployment ${{ job.status }}'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}

  # Deploy to Production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production'
    environment:
      name: production
      url: https://salon.app

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create release tag
        id: tag
        run: |
          VERSION=$(date +'%Y.%m.%d')-${GITHUB_SHA::8}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          git tag $VERSION
          git push origin $VERSION

      - name: Configure SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
          SSH_HOST: ${{ secrets.PRODUCTION_HOST }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H $SSH_HOST >> ~/.ssh/known_hosts

      - name: Create database backup
        env:
          SSH_HOST: ${{ secrets.PRODUCTION_HOST }}
          SSH_USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh -i ~/.ssh/deploy_key $SSH_USER@$SSH_HOST << 'ENDSSH'
            set -e
            echo "ðŸ’¾ Creating database backup..."

            cd ${{ secrets.PRODUCTION_DEPLOY_PATH }}

            BACKUP_FILE="backup-$(date +'%Y%m%d-%H%M%S').sql"
            docker-compose exec -T postgres pg_dump -U salon salon > backups/$BACKUP_FILE

            echo "âœ… Backup created: $BACKUP_FILE"
          ENDSSH

      - name: Deploy to production server
        env:
          SSH_HOST: ${{ secrets.PRODUCTION_HOST }}
          SSH_USER: ${{ secrets.PRODUCTION_USER }}
          DEPLOY_PATH: ${{ secrets.PRODUCTION_DEPLOY_PATH }}
        run: |
          ssh -i ~/.ssh/deploy_key $SSH_USER@$SSH_HOST << 'ENDSSH'
            set -e

            echo "ðŸš€ Deploying to production..."

            # Navigate to deployment directory
            cd ${{ secrets.PRODUCTION_DEPLOY_PATH }}

            # Pull latest changes
            git fetch origin
            git reset --hard origin/main

            # Build and deploy with Docker
            docker-compose -f docker-compose.yml -f docker-compose.prod.yml pull
            docker-compose -f docker-compose.yml -f docker-compose.prod.yml build --no-cache

            # Enable maintenance mode
            docker-compose exec -T app php artisan down --retry=60

            # Update containers
            docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d --force-recreate

            # Wait for services
            echo "â³ Waiting for services to start..."
            sleep 15

            # Run migrations
            echo "ðŸ“Š Running database migrations..."
            docker-compose exec -T app php artisan migrate --force

            # Optimize application
            echo "ðŸ”§ Optimizing application..."
            docker-compose exec -T app php artisan config:cache
            docker-compose exec -T app php artisan route:cache
            docker-compose exec -T app php artisan view:cache
            docker-compose exec -T app php artisan optimize

            # Clear application cache
            docker-compose exec -T app php artisan cache:clear

            # Restart queue workers
            docker-compose restart queue

            # Disable maintenance mode
            docker-compose exec -T app php artisan up

            echo "âœ… Production deployment complete!"
          ENDSSH

      - name: Health check
        run: |
          sleep 15
          for i in {1..5}; do
            if curl --fail https://salon.app/api/health; then
              echo "âœ… Health check passed"
              exit 0
            fi
            echo "â³ Waiting for application to be ready..."
            sleep 5
          done
          echo "âŒ Health check failed"
          exit 1

      - name: Smoke tests
        run: |
          echo "ðŸ§ª Running smoke tests..."

          # Test API endpoints
          curl --fail https://salon.app/api/health
          curl --fail https://salon.app/api/services

          echo "âœ… Smoke tests passed"

      - name: Create GitHub release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.tag.outputs.version }}
          release_name: Release ${{ steps.tag.outputs.version }}
          draft: false
          prerelease: false

      - name: Notify deployment
        uses: 8398a7/action-slack@v3
        if: always()
        with:
          status: ${{ job.status }}
          text: 'Production deployment ${{ job.status }} - Version: ${{ steps.tag.outputs.version }}'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}

  # Rollback (manual trigger only)
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure()
    environment:
      name: production

    steps:
      - name: Rollback production
        env:
          SSH_HOST: ${{ secrets.PRODUCTION_HOST }}
          SSH_USER: ${{ secrets.PRODUCTION_USER }}
          SSH_PRIVATE_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H $SSH_HOST >> ~/.ssh/known_hosts

          ssh -i ~/.ssh/deploy_key $SSH_USER@$SSH_HOST << 'ENDSSH'
            set -e

            echo "âš ï¸ Rolling back deployment..."

            cd ${{ secrets.PRODUCTION_DEPLOY_PATH }}

            # Rollback to previous commit
            git reset --hard HEAD^

            # Restart containers
            docker-compose -f docker-compose.yml -f docker-compose.prod.yml restart

            # Disable maintenance mode
            docker-compose exec -T app php artisan up

            echo "âœ… Rollback complete"
          ENDSSH

      - name: Notify rollback
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              text: 'âš ï¸ Deployment rolled back due to failure'
            }
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
